# **Instclone**


Проект созданный в качестве практики изученному материалу (Django, DRF). Прототипом послужил небезызвестный Instagram. Из-за ограниченных знаний в области Front-end, было принято решение создать примитивный пользовательский интерфейс при помощи Django Templates. 

## **В проекте был реализован следующий функционал:**
+ Регистрация пользователей на сайте(создание аккаунта)
+ Добавление и изменение аватара профиля
+ Добавление и удаление постов (фотографий) в профиль
+ Добавление и удаление комментариев под постами
+ Добавление и удаление "лайка" под постами
+ Возможность подписываться на других пользователей
+ Просмотр ленты, в которой отображются посты текущего авторизированного пользователя и посты тех на кого он подписан
+ Просмотр ленты, в которой отображаются вообще все посты в целом
+ Раздел уведомлений в котором отображается следующая информация:

  + Уведомление о "лайках" 
  + Уведомления о подписках 
  + Уведомелния о комментариях под постом
  + Уведомления о побликации поста пользователем на котого есть подписка


DRF в данном случае просто дублирует функционал, предоставляя возможность взаимодействия через API.

Помимо стандартных Django и DRF, в проекте так же фигурируют следующие инструменты:
+ Celery
+ Redis
+ WebSocket
+ S3 Хранилище
+ Nginx

## **Celery**

Celery используется в связке с Redis для создания уведомлений. Например, когда отрабатывает функция по добавлению фотографий или добавлению комментария, создается таска, которая в свою очередь создает запись в БД об этом событии, для необходимых пользователей. 
После чего запускается рассылка уведомлений через websocket,пользователям которые сейчас находятся на сайте.

## **Redis**

Redis используется сразу для нескольких задач:
1. В качестве брокера для Celery
2. В связке с WebSoket для хранения id пользователей которые сейчас находятся на сайте
3. Для глобального кэширования при помощи cachalot


## **WebSocket**

WebSocket используется для отправки новых уведомлений. Когда пользователь заходит на сайт, срабатывает JS скрипт который в свою очередь вызывает функцию для создания соединения
```python
async def connect(self):
	user = self.scope['user']
	redis_client.set(f"user_{user.id}_channel", self.channel_name)
	await self.accept()
```
Тут создается уникальная запись, которая сохраняется в базу данных Redis, для того чтобы в дальнейшем можно было отправлять уведомления именно этому пользователю.

## **S3 Хранилище**

Для того чтобы фотографии сохраняюсь не в корень проекта, было принятно решение использовать хранлище. Мной было выбрано S3 Minio по нескольким пунктам:
1. Бесплатное
2. Взаимодейстие осуществяется при помощи популярной библиотеки s3boto
3. Имеет удобный графический интерфейс для работы с бакетами и прочими настройками

В хранилище находятся 2 папки, avatar и photos в которые соответственно и загружаюстся фотографии.
Перед сохранением, название файла изменяется на сгенерированнную последовательность символов (при помощи uuid)

## **Nginx**

В данном проекте он используется в качестве обратного прокси сервера. Для большей наглядности я поместил его в docker-compose, хотя на сколько я понимаю так вообще не делается и он отдельно настраивается на Linux машине. Так же, помимо передачи запросов он еще отдает статические файлы (HTML, CSS, JS).

## **Использование**

Приложение запускает при помощи docker-compose файла. Все необходимые зависимости скачаются и установятся самостоятельно. В самом репозитории (в корне проекта) отсутствует файл .env с необхомыми паролями и переменными. Он имеет следующую структуру:

```ini
DEBUG=
ALLOWED_HOSTS=
SECRET_KEY=
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_STORAGE_BUCKET_NAME=
AWS_S3_ENDPOINT_URL=
AWS_S3_ENDPOINT=
SQL_NAME=
SQL_USER=
SQL_PASS=
SQL_HOST=
SQL_PORT=
BROKER_URL=
REDIS_HOST=
POSTGRES_USER=
POSTGRES_PASSWORD=
POSTGRES_DB=
MINIO_ROOT_USER=
MINIO_ROOT_PASSWORD=
```

Остается только запустить файл docker-compose:
```docker
docker-compose -f docker-compose.prod.yml up --build -d
```
